<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Variante B – Intrinsics aus Zentroid-JSON</title>
  <style>
    :root { color-scheme: light dark; }
    * { box-sizing: border-box; }
    body { margin: 0; padding: 20px; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; display:flex; justify-content:center; }
    .wrap { width: min(1100px, 100%); }
    h1 { margin: 0 0 10px; font-size: 20px; line-height: 1.25; }
    h2 { margin: 0 0 10px; font-size: 16px; }
    .hint { font-size: 13px; opacity: 0.85; margin-bottom: 14px; }
    .card { border: 1px solid rgba(127,127,127,.35); border-radius: 14px; padding: 14px; background: rgba(127,127,127,.06); }
    .card + .card { margin-top: 12px; }
    .form-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(190px, 1fr)); gap: 12px; align-items:end; }
    .field label { display:block; font-size: 12px; opacity: .9; margin-bottom: 6px; }
    .field input[type="number"] { width: 100%; padding: 10px 12px; border-radius: 12px; border: 1px solid rgba(127,127,127,.35); background: transparent; line-height: 1.1; }
    .actions { margin-top: 12px; display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    button { padding: 10px 12px; border-radius: 12px; border: 1px solid rgba(127,127,127,.45); background: transparent; cursor:pointer; min-width: 150px; }
    button.primary { border-color: rgba(80,140,255,.85); }
    button:disabled { opacity:.55; cursor:not-allowed; }
    .status { font-size: 13px; opacity:.9; margin-top: 10px; padding: 10px 12px; border-radius: 12px; border: 1px dashed rgba(127,127,127,.35); background: rgba(127,127,127,.05); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    pre { white-space: pre-wrap; word-break: break-word; background: rgba(127,127,127,.10); padding: 12px; border-radius: 12px; border: 1px solid rgba(127,127,127,.25); margin: 0; }
    .kpi { display:grid; grid-template-columns: repeat(auto-fit, minmax(230px, 1fr)); gap: 10px; margin: 10px 0 12px; }
    .kpi .box { border: 1px solid rgba(127,127,127,.25); border-radius: 12px; padding: 10px 12px; background: rgba(127,127,127,.04); }
    .kpi .box .t { font-size: 12px; opacity: .85; margin-bottom: 4px; }
     .kpi .box .v { font-size: 14px; font-weight: 600; }

    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { text-align: left; padding: 6px 8px; border-bottom: 1px solid rgba(127,127,127,.25); vertical-align: top; }
    th { opacity: .9; }
  </style>
</head>
<body>
  <div class="wrap">
  <h1>Variante B: Target-Inputs → JSON importieren → Intrinsics berechnen</h1>
  <div class="hint">
    Diese Seite lädt <span class="mono">math_helper.js</span> (global <span class="mono">MathHelper</span>) und importiert
    <span class="mono">RealWorldTargetInputCalculation_2.js</span> als ES‑Modul. <b>Wichtig:</b> Öffne die HTML über einen lokalen Webserver
    (z. B. <span class="mono">python -m http.server</span>), da Browser ES‑Module von <span class="mono">file://</span> oft blocken.
  </div>

  <div class="card">
    <div class="form-grid">
      <div class="field">
        <label for="cols">cols</label>
        <input id="cols" type="number" min="1" step="1" value="6" />
      </div>
      <div class="field">
        <label for="rows">rows</label>
        <input id="rows" type="number" min="1" step="1" value="8" />
      </div>
      <div class="field">
        <label for="pitchMm">pitchMm</label>
        <input id="pitchMm" type="number" min="0.001" step="0.1" value="20" />
      </div>

      <div class="field">
        <label for="paperWmm">paperWmm</label>
        <input id="paperWmm" type="number" min="1" step="1" value="210" />
      </div>
      <div class="field">
        <label for="paperHmm">paperHmm</label>
        <input id="paperHmm" type="number" min="1" step="1" value="297" />
      </div>
      <div class="field">
        <label for="marginMm">marginMm</label>
        <input id="marginMm" type="number" min="0" step="0.1" value="10" />
      </div>

      <div class="field">
        <label for="circleDiameterMm">circleDiameterMm</label>
        <input id="circleDiameterMm" type="number" min="0" step="0.1" value="6" />
      </div>
    </div>

    <div class="actions">
      <button id="btnImport" class="primary">JSON importieren</button>
      <button id="btnCalibrate" class="primary" disabled>Calibrate</button>
      <button id="btnDownload" disabled>Result JSON</button>
    </div>

    <input id="fileInput" type="file" accept=".json,application/json" style="display:none" />
    <div class="status" id="status">Noch keine Datei importiert.</div>
  </div>

  <div class="card">
    <h2>Ergebnis</h2>
    <div id="summary"></div>
    <pre id="out" class="mono">—</pre>
  </div>

  <!-- math_helper.js defines window.MathHelper -->
  <script src="./math_helper.js"></script>

  <script type="module">
    import { generateAndPlace } from "./RealWorldTargetInputCalculation_2.js";

    const $ = (id) => document.getElementById(id);

    const els = {
      cols: $("cols"),
      rows: $("rows"),
      pitchMm: $("pitchMm"),
      paperWmm: $("paperWmm"),
      paperHmm: $("paperHmm"),
      marginMm: $("marginMm"),
      circleDiameterMm: $("circleDiameterMm"),
      btnImport: $("btnImport"),
      btnCalibrate: $("btnCalibrate"),
      btnDownload: $("btnDownload"),
      fileInput: $("fileInput"),
      status: $("status"),
      out: $("out"),
      summary: $("summary"),
    };

    if (!window.MathHelper) {
      els.status.textContent = "Fehler: MathHelper nicht gefunden. Liegt math_helper.js im gleichen Ordner?";
      els.status.style.color = "crimson";
    }

    let imported = null;   // raw JSON
    let lastResult = null; // calibration output

    function readNum(el) {
      const v = Number(el.value);
      if (!Number.isFinite(v)) throw new Error("Ungültiger Wert: " + el.id);
      return v;
    }

    function buildObjectPoints() {
      const cols = Math.trunc(readNum(els.cols));
      const rows = Math.trunc(readNum(els.rows));
      const pitchMm = readNum(els.pitchMm);
      const paperWmm = readNum(els.paperWmm);
      const paperHmm = readNum(els.paperHmm);
      const marginMm = readNum(els.marginMm);
      const circleDiameterMm = readNum(els.circleDiameterMm);

      const { placedPoints, fits, offsetX, offsetY } = generateAndPlace({
        cols, rows, pitchMm, paperWmm, paperHmm, marginMm, circleDiameterMm
      });

      // Object points in target-plane units (mm). id must match centroid ids.
      const objPoints = placedPoints.map(p => ({
        id: p.index,
        X: p.pageX,
        Y: p.pageY
      }));

      return { objPoints, fits, offsetX, offsetY, cols, rows, pitchMm, paperWmm, paperHmm, marginMm, circleDiameterMm };
    }

    function parseExport(json) {
      // Supports your IndexedDB export structure:
      // { items: { "<key>": { centroids:[{id,x,y},...], ... }, ... } }
      const items = json?.items;
      if (!items || typeof items !== "object") throw new Error("JSON: Erwartet Feld 'items' (object).");

      const images = [];
      for (const [key, item] of Object.entries(items)) {
        const centroids = item?.centroids;
        if (!Array.isArray(centroids) || centroids.length === 0) continue;

        const points = centroids.map(c => ({
          id: c.id,
          u: c.x,
          v: c.y
        }));

        images.push({
          name: item.titel || key,
          points
        });
      }

      if (images.length === 0) throw new Error("Keine 'centroids' gefunden (in items[*].centroids).");

      return images;
    }

    function fmt(n, d=6) {
      if (!Number.isFinite(n)) return String(n);
      const abs = Math.abs(n);
      if (abs !== 0 && (abs < 1e-4 || abs > 1e6)) return n.toExponential(6);
      return n.toFixed(d);
    }

    function setStatus(msg, ok=true) {
      els.status.textContent = msg;
      els.status.style.color = ok ? "" : "crimson";
    }

    function renderResult(result) {
      const K = result.K;
      const dist = result.dist; // [k1,k2,k3,p1,p2]
      const fx = K[0][0], skew = K[0][1], cx = K[0][2];
      const fy = K[1][1], cy = K[1][2];

      const k1 = dist[0] ?? 0;
      const k2 = dist[1] ?? 0;
      const k3 = dist[2] ?? 0;
      const p1 = dist[3] ?? 0;
      const p2 = dist[4] ?? 0;

      // summary table
      els.summary.innerHTML = `
        <div class="kpi">
          <div class="box">
            <div class="t">Focal Length</div>
            <div class="v"><span class="mono">fx=${fmt(fx,4)}</span> px · <span class="mono">fy=${fmt(fy,4)}</span> px</div>
          </div>
          <div class="box">
            <div class="t">Principal Point</div>
            <div class="v"><span class="mono">cx=${fmt(cx,4)}</span> px · <span class="mono">cy=${fmt(cy,4)}</span> px</div>
          </div>
          <div class="box">
            <div class="t">Reprojection Error</div>
            <div class="v"><span class="mono">RMS=${fmt(result.rms,6)}</span> px</div>
          </div>
        </div>

        <table>
          <tr><th>Distortion</th><th class="mono">Wert</th></tr>
          <tr><td>k1</td><td class="mono">${fmt(k1,8)}</td></tr>
          <tr><td>k2</td><td class="mono">${fmt(k2,8)}</td></tr>
          <tr><td>p1</td><td class="mono">${fmt(p1,8)}</td></tr>
          <tr><td>p2</td><td class="mono">${fmt(p2,8)}</td></tr>
          <tr><td>k3</td><td class="mono">${fmt(k3,8)}</td></tr>
          <tr><td>Skew</td><td class="mono">${fmt(skew,6)}</td></tr>
        </table>
      `;

      const pretty = {
        K,
        // order as you asked: k1,k2,p1,p2,k3
        distortion: { k1, k2, p1, p2, k3 },
        rmsPx: result.rms,
        // optional: per image extrinsics
        extrinsics: result.rvecs.map((rvec, i) => ({
          imageIndex: i,
          rvec,
          tvec: result.tvecs[i]
        }))
      };

      els.out.textContent = JSON.stringify(pretty, null, 2);
      lastResult = pretty;
      els.btnDownload.disabled = false;
    }

    // Import
    els.btnImport.addEventListener("click", () => els.fileInput.click());
    els.fileInput.addEventListener("change", async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) return;

      try {
        const text = await file.text();
        imported = JSON.parse(text);
        const images = parseExport(imported);

        // Update status with quick sanity checks
        const totalCentroids = images.reduce((s, im) => s + im.points.length, 0);
        setStatus(`Import ok: ${images.length} image(s), ${totalCentroids} centroid(s).`);

        els.btnCalibrate.disabled = false;
        els.btnDownload.disabled = true;
        els.summary.innerHTML = "";
        els.out.textContent = "Bereit. Klicke „Calibrate“.";
      } catch (e) {
        console.error(e);
        imported = null;
        els.btnCalibrate.disabled = true;
        els.btnDownload.disabled = true;
        setStatus("Import fehlgeschlagen: " + (e?.message || e), false);
      } finally {
        // allow re-import same file
        ev.target.value = "";
      }
    });

    // Calibrate
    els.btnCalibrate.addEventListener("click", () => {
      if (!imported) return;

      try {
        const images = parseExport(imported);
        const { objPoints, fits, cols, rows, pitchMm, paperWmm, paperHmm, marginMm, circleDiameterMm } = buildObjectPoints();

        // sanity: centroid ids must be within [0, cols*rows-1]
        const maxId = cols*rows - 1;
        let bad = 0, kept = 0;
        for (const im of images) {
          im.points = im.points.filter(p => {
            const ok = Number.isInteger(p.id) && p.id >= 0 && p.id <= maxId;
            if (!ok) bad++;
            else kept++;
            return ok;
          });
        }

        if (!fits) {
          setStatus("Warnung: Grid passt laut Papier/Margin nicht (fits=false). Berechnung läuft trotzdem.", false);
        } else {
          setStatus(`Calibrate läuft… (cols=${cols}, rows=${rows}, pitch=${pitchMm}mm)`);
        }

        if (kept < 12) throw new Error("Zu wenig gültige Punkte nach ID-Filter. Prüfe cols/rows und centroid IDs.");

        // Do the calibration
        const result = window.MathHelper.calibratePlanarFromPoints(
          objPoints,
          images.map(im => ({ points: im.points })),
          {
            distModel: "radial-tangential",
            optimizeSkew: false,
            maxIters: 25,
            lambda0: 1e-3,
            jacEps: 1e-6,
            tol: 1e-6,
            verbose: false
          }
        );

        renderResult(result);
        setStatus(`Fertig: RMS=${result.rms.toFixed(3)} px · Bilder=${images.length} · Punkte/Img≈${Math.round(kept/images.length)}`);
      } catch (e) {
        console.error(e);
        els.summary.innerHTML = "";
        els.out.textContent = "—";
        lastResult = null;
        els.btnDownload.disabled = true;
        setStatus("Calibrate fehlgeschlagen: " + (e?.message || e), false);
      }
    });

    // Download result JSON
    els.btnDownload.addEventListener("click", () => {
      if (!lastResult) return;
      const blob = new Blob([JSON.stringify(lastResult, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "calibration_result.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });
  </script>
  </div>
</body>
</html>
