<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Camera + Orientation Capture</title>

  <!-- ZIP Library (JSZip) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <style>
    :root{
      --bg:#0b0c10;
      --card:#12141c;
      --muted:#a9b0c3;
      --text:#eef1ff;
      --accent:#7c5cff;
      --danger:#ff4d6d;
      --radius:18px;
      --border: rgba(255,255,255,.10);
      --glass: rgba(0,0,0,.35);
    }
    *{box-sizing:border-box;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    body{margin:0;background:linear-gradient(180deg,#07080c, #0b0c10);color:var(--text);}
    .wrap{max-width:620px;margin:0 auto;min-height:100dvh;display:flex;flex-direction:column;}
    header{
      padding:14px 14px 10px 14px;
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
    }
    .leftHead{display:flex;flex-direction:column;gap:6px}
    .title{font-weight:800;letter-spacing:.2px;font-size:14px;color:#dfe3ff;opacity:.95}
    .pill{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      padding:8px 10px;border-radius:999px;color:var(--muted);font-size:12px
    }
    .btn{
      border:0;border-radius:999px;padding:10px 12px;font-weight:750;
      background:rgba(255,255,255,.08);color:var(--text);
      border:1px solid rgba(255,255,255,.14);
      cursor:pointer; user-select:none;
    }
    .btn.primary{background:var(--accent);border-color:transparent;}
    .btn.danger{background:rgba(255,77,109,.14);border-color:rgba(255,77,109,.35);color:#ffd6de;}
    .btn:disabled{opacity:.45;cursor:not-allowed;}

    .stage{padding:0 14px 14px 14px;flex:1;display:flex;flex-direction:column;gap:12px;}
    .viewfinder{
      position:relative;
      flex:1;
      min-height:420px;
      background:var(--card);
      border:1px solid var(--border);
      border-radius:var(--radius);
      overflow:hidden;
      box-shadow:0 20px 60px rgba(0,0,0,.35);
    }
    video{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      transform:scaleX(-1);
    }
    .back video{transform:none;} /* back camera: no mirror */

    .hudTop{
      position:absolute;left:10px;top:10px;right:10px;
      display:flex;justify-content:space-between;gap:10px;
      pointer-events:none;
    }
    .hudCol{display:flex;flex-direction:column;gap:6px;min-width:180px}
    .hudCol.right{align-items:flex-end;min-width:auto}
    .hudCol .pill{
      backdrop-filter:blur(10px);
      background:var(--glass);
      border-color:rgba(255,255,255,.14);
      color:#d6dbf0;
    }

    .portraitBlock{
      position:absolute;inset:0;
      display:none;align-items:center;justify-content:center;text-align:center;
      padding:22px;background:rgba(0,0,0,.72);backdrop-filter:blur(10px);
    }
    .portraitBlock.show{display:flex;}
    .portraitBlock .card{
      background:rgba(18,20,28,.85);
      border:1px solid rgba(255,255,255,.14);
      border-radius:22px;padding:18px;max-width:340px;
    }
    .portraitBlock h2{margin:0 0 8px 0;font-size:18px;}
    .portraitBlock p{margin:0;color:var(--muted);font-size:13px;line-height:1.35}

    .panel{
      background:rgba(255,255,255,.04);
      border:1px solid var(--border);
      border-radius:22px;
      padding:12px;
      display:flex;flex-direction:column;gap:10px;
    }
    .row{display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;}

    .thumb{
      width:64px;height:64px;border-radius:16px;overflow:hidden;border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      flex:0 0 auto;
    }
    .thumb img{width:100%;height:100%;object-fit:cover;display:block;}

    details{
      background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.10);
      border-radius:18px;
      padding:10px 12px;
    }
    summary{
      cursor:pointer;
      color:#dfe3ff;
      font-weight:750;
      font-size:12px;
      list-style:none;
    }
    summary::-webkit-details-marker{display:none;}
    .detailsBody{margin-top:10px;display:flex;flex-direction:column;gap:10px}

    select{
      width:100%;
      background:rgba(255,255,255,.06);
      color:var(--text);
      border:1px solid rgba(255,255,255,.14);
      border-radius:12px;
      padding:10px;
    }

    .zoomRow{display:flex;gap:8px;flex-wrap:wrap;}
    .chip{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:8px 10px;border-radius:999px;
      cursor:pointer;font-weight:800;
      font-size:12px;
    }
    .chip.active{background:rgba(124,92,255,.22);border-color:rgba(124,92,255,.65);}

    footer{padding:10px 14px 16px 14px;color:var(--muted);font-size:12px;line-height:1.35}
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;}
  </style>
</head>

<body>
<div class="wrap">
  <header>
    <div class="leftHead">
      <div class="title">Camera Capture + Orientation</div>
      <div class="pill" id="statusPill">Bereit</div>
    </div>

    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
      <button class="btn" id="btnFullscreen">Fullscreen</button>
      <button class="btn primary" id="btnStart">Start</button>
      <button class="btn danger" id="btnStop" disabled>Stop</button>
    </div>
  </header>

  <div class="stage">
    <div class="viewfinder back" id="viewfinder">
      <div class="hudTop">
        <div class="hudCol">
          <div class="pill" id="pillOrientation">Portrait: ?</div>
          <div class="pill" id="pillHeading">Heading: —</div>
          <div class="pill" id="pillEuler">Yaw/Pitch/Roll: — / — / —</div>
        </div>
        <div class="hudCol right">
          <div class="pill" id="pillZoom">Zoom: —</div>
          <div class="pill" id="pillCount">Records: 0</div>
        </div>
      </div>

      <video id="video" playsinline muted></video>

      <div class="portraitBlock" id="portraitBlock">
        <div class="card">
          <h2>Bitte ins Hochformat drehen</h2>
          <p>Fotoaufnahme ist nur im Portrait-Modus aktiv.</p>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="row">
        <button class="btn primary" id="btnShot" disabled>Foto aufnehmen</button>
        <div class="thumb" title="Letztes Foto">
          <img id="thumb" alt="" />
        </div>

        <button class="btn" id="btnExportZip" disabled>ZIP export</button>
        <button class="btn danger" id="btnClear" disabled>Session löschen</button>
      </div>

      <details>
        <summary>Optionen</summary>
        <div class="detailsBody">
          <div class="row" style="width:100%;gap:12px;align-items:flex-start;">
            <div style="flex:1;min-width:220px;">
              <div class="pill" style="display:inline-block;margin-bottom:8px;">Kamera wählen</div>
              <select id="cameraSelect" disabled></select>
            </div>
            <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
              <button class="btn" id="btnFlip" disabled>Front/Back</button>
            </div>
          </div>

          <div>
            <div class="pill" style="display:inline-block;margin-bottom:8px;">Zoom (best effort)</div>
            <div class="zoomRow" id="zoomRow">
              <button class="chip" data-z="0.5">0,5x</button>
              <button class="chip active" data-z="1">1x</button>
              <button class="chip" data-z="2">2x</button>
              <button class="chip" data-z="5">5x</button>
            </div>
            <div class="pill" id="hint" style="margin-top:10px;">
              Hinweis: iOS Safari kann Zoom/Linsenwechsel im Web einschränken. ZIP enthält Fotos nur, solange die Seite nicht neu geladen wurde.
            </div>
          </div>
        </div>
      </details>
    </div>
  </div>

  <footer>
    iOS: Kamera + Motion/Kompass funktionieren am zuverlässigsten über <b>HTTPS</b>.  
    Start-Button startet Kamera <i>und</i> fragt Motion/Orientation-Permissions an (User-Gesture).  
    ZIP enthält <code>captures.json</code> + Fotos (RAM).
  </footer>
</div>

<script>
(() => {
  const els = {
    video: document.getElementById('video'),
    viewfinder: document.getElementById('viewfinder'),
    portraitBlock: document.getElementById('portraitBlock'),

    statusPill: document.getElementById('statusPill'),
    pillOrientation: document.getElementById('pillOrientation'),
    pillHeading: document.getElementById('pillHeading'),
    pillEuler: document.getElementById('pillEuler'),
    pillZoom: document.getElementById('pillZoom'),
    pillCount: document.getElementById('pillCount'),

    btnStart: document.getElementById('btnStart'),
    btnStop: document.getElementById('btnStop'),
    btnShot: document.getElementById('btnShot'),
    btnExportZip: document.getElementById('btnExportZip'),
    btnClear: document.getElementById('btnClear'),

    btnFlip: document.getElementById('btnFlip'),
    cameraSelect: document.getElementById('cameraSelect'),
    zoomRow: document.getElementById('zoomRow'),
    hint: document.getElementById('hint'),

    btnFullscreen: document.getElementById('btnFullscreen'),
    thumb: document.getElementById('thumb'),
  };

  // -------------------------
  // Storage: only metadata
  // -------------------------
  const STORE_KEY = "captures_v1"; // metadata only

  function loadCaptures(){
    try { return JSON.parse(sessionStorage.getItem(STORE_KEY) || "[]"); }
    catch { return []; }
  }

  function saveCaptures(arr){
    sessionStorage.setItem(STORE_KEY, JSON.stringify(arr));
    els.btnExportZip.disabled = arr.length === 0;
    els.btnClear.disabled = arr.length === 0;
    els.pillCount.textContent = `Records: ${arr.length}`;
  }

  function nextId(arr){
    const max = arr.reduce((m, x) => Math.max(m, Number(x.id)||0), 0);
    return max + 1;
  }

  function padId(id){ return String(id).padStart(4, "0"); }

  function setStatus(t){ els.statusPill.textContent = t; }

  // -------------------------
  // In-memory photo store (no base64 persistence, no indexeddb)
  // -------------------------
  // Store photos as Blobs in RAM for ZIP export
  const photoBlobs = new Map(); // id -> { filename, blob }

  function downloadBlob(filename, blob){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }

  // -------------------------
  // Orientation/Motion
  // -------------------------
  let motionActive = false;
  let latest = { heading:null, yaw:null, pitch:null, roll:null, ts:null };

  function updateSensorUI(){
    const h = latest.heading;
    const y = latest.yaw, p = latest.pitch, r = latest.roll;
    els.pillHeading.textContent = (h == null) ? "Heading: —" : `Heading: ${h.toFixed(0)}°`;
    if (y == null || p == null || r == null){
      els.pillEuler.textContent = "Yaw/Pitch/Roll: — / — / —";
    } else {
      els.pillEuler.textContent = `Yaw/Pitch/Roll: ${y.toFixed(0)}° / ${p.toFixed(0)}° / ${r.toFixed(0)}°`;
    }
  }

  function startOrientationListeners(){
    if (motionActive) return;
    motionActive = true;

    window.addEventListener('deviceorientation', (ev) => {
      // Heading: iOS Safari non-standard
      const heading = (typeof ev.webkitCompassHeading === 'number')
        ? ev.webkitCompassHeading
        : (typeof ev.alpha === 'number' ? ev.alpha : null);

      // Pragmatic Euler-ish mapping:
      // yaw ~ alpha, pitch ~ beta, roll ~ gamma
      const yaw   = (typeof ev.alpha === 'number') ? ev.alpha : null;
      const pitch = (typeof ev.beta  === 'number') ? ev.beta  : null;
      const roll  = (typeof ev.gamma === 'number') ? ev.gamma : null;

      latest = { heading, yaw, pitch, roll, ts: Date.now() };
      updateSensorUI();
    }, { passive:true });
  }

  async function requestMotionPermissionAndStart(){
    // Must be called from user gesture on iOS
    let ok = true;

    try{
      if (typeof DeviceOrientationEvent !== 'undefined'
          && typeof DeviceOrientationEvent.requestPermission === 'function') {
        const res = await DeviceOrientationEvent.requestPermission();
        ok = (res === 'granted');
      }
    } catch(e){
      ok = false;
    }

    try{
      if (ok && typeof DeviceMotionEvent !== 'undefined'
          && typeof DeviceMotionEvent.requestPermission === 'function') {
        const res2 = await DeviceMotionEvent.requestPermission();
        ok = ok && (res2 === 'granted');
      }
    } catch(e){
      ok = false;
    }

    if (!ok){
      setStatus("Motion/Kompass: abgelehnt");
      return false;
    }

    startOrientationListeners();
    setStatus("Motion/Kompass aktiv");
    return true;
  }

  // -------------------------
  // Portrait gate
  // -------------------------
  function isPortrait(){
    return window.matchMedia && window.matchMedia("(orientation: portrait)").matches;
  }

  function updatePortraitUI(){
    const ok = isPortrait();
    els.pillOrientation.textContent = "Portrait: " + (ok ? "Ja" : "Nein");
    els.portraitBlock.classList.toggle('show', !ok);
    els.btnShot.disabled = !ok || !stream;
  }

  window.addEventListener('orientationchange', updatePortraitUI);
  window.addEventListener('resize', updatePortraitUI);

  // -------------------------
  // Camera
  // -------------------------
  let stream = null;
  let videoTrack = null;
  let currentDeviceId = null;
  let facing = "environment";

  async function refreshDeviceList(){
    if (!navigator.mediaDevices?.enumerateDevices) return;
    const devices = await navigator.mediaDevices.enumerateDevices();
    const cams = devices.filter(d => d.kind === 'videoinput');

    els.cameraSelect.innerHTML = "";
    cams.forEach((c, idx) => {
      const opt = document.createElement('option');
      opt.value = c.deviceId;
      opt.textContent = c.label ? c.label : `Kamera ${idx+1}`;
      if (currentDeviceId && c.deviceId === currentDeviceId) opt.selected = true;
      els.cameraSelect.appendChild(opt);
    });

    els.cameraSelect.disabled = cams.length === 0;
  }

  function updateZoomUIFromCapabilities(){
    if (!videoTrack?.getCapabilities){
      els.pillZoom.textContent = "Zoom: —";
      return;
    }
    const caps = videoTrack.getCapabilities();
    if (caps && 'zoom' in caps){
      els.pillZoom.textContent = `Zoom: supported (${caps.zoom.min}–${caps.zoom.max})`;
    } else {
      els.pillZoom.textContent = "Zoom: nicht exposed";
    }
  }

  async function trySetZoom(z){
    if (!videoTrack?.getCapabilities || !videoTrack?.applyConstraints) return false;
    const caps = videoTrack.getCapabilities();
    if (!caps || !('zoom' in caps)) return false;

    const target = Math.min(caps.zoom.max, Math.max(caps.zoom.min, z));
    try{
      await videoTrack.applyConstraints({ advanced: [{ zoom: target }] });
      els.pillZoom.textContent = `Zoom: ${target.toFixed(2)}`;
      return true;
    } catch(e){
      return false;
    }
  }

  async function startCamera({ deviceId=null, facingMode="environment" } = {}){
    stopCamera();

    const constraints = {
      audio: false,
      video: {
        width:  { ideal: 1280 },
        height: { ideal: 720 },
        facingMode: deviceId ? undefined : { ideal: facingMode },
        deviceId:  deviceId ? { exact: deviceId } : undefined
      }
    };

    setStatus("Kamera-Permission…");
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    els.video.srcObject = stream;

    await new Promise(res => els.video.onloadedmetadata = res);
    await els.video.play();

    videoTrack = stream.getVideoTracks()[0];
    const settings = videoTrack.getSettings?.() || {};
    currentDeviceId = settings.deviceId || deviceId || null;

    if (facingMode === "user") els.viewfinder.classList.remove('back');
    else els.viewfinder.classList.add('back');

    els.btnStop.disabled = false;
    els.btnFlip.disabled = false;

    await refreshDeviceList();
    updateZoomUIFromCapabilities();
    updatePortraitUI();

    setStatus("Kamera läuft");
  }

  function stopCamera(){
    if (stream) stream.getTracks().forEach(t => t.stop());
    stream = null;
    videoTrack = null;
    currentDeviceId = null;
    els.video.srcObject = null;

    els.btnStop.disabled = true;
    els.btnFlip.disabled = true;
    els.cameraSelect.disabled = true;
    els.btnShot.disabled = true;

    setStatus("Gestoppt");
    updatePortraitUI();
  }

  async function flipCamera(){
    facing = (facing === "environment") ? "user" : "environment";
    await startCamera({ facingMode: facing });
  }

  async function selectCameraByDeviceId(deviceId){
    const opt = [...els.cameraSelect.options].find(o => o.value === deviceId);
    const label = (opt?.textContent || "").toLowerCase();
    facing = (label.includes("front") || label.includes("vorne")) ? "user" : "environment";
    await startCamera({ deviceId, facingMode: facing });
  }

  async function capturePhoto(){
    if (!stream || !isPortrait()) return;

    const captures = loadCaptures();
    const id = nextId(captures);
    const filename = `photo_${padId(id)}.jpg`;

    const v = els.video;
    const canvas = document.createElement('canvas');
    canvas.width = v.videoWidth;
    canvas.height = v.videoHeight;

    const ctx = canvas.getContext('2d');
    ctx.drawImage(v, 0, 0, canvas.width, canvas.height);

    // Create Blob (better for ZIP) + also preview thumbnail + optional direct download
    const blob = await new Promise(resolve => canvas.toBlob(resolve, "image/jpeg", 0.92));
    if (!blob){
      setStatus("Foto Fehler");
      return;
    }

    // keep in RAM for ZIP
    photoBlobs.set(id, { filename, blob });

    // thumbnail preview
    const url = URL.createObjectURL(blob);
    els.thumb.src = url;
    // release old object URLs later to avoid leaks
    setTimeout(() => URL.revokeObjectURL(url), 60_000);

    // OPTIONAL: direct download of each photo file (uncomment if you want)
    // downloadBlob(filename, blob);

    // metadata record in sessionStorage
    const rec = {
      id,
      ts: new Date().toISOString(),
      heading: latest.heading,
      yaw: latest.yaw,
      pitch: latest.pitch,
      roll: latest.roll
    };
    captures.push(rec);
    saveCaptures(captures);

    setStatus(`Gespeichert #${id}`);
  }

  // -------------------------
  // ZIP export (captures.json + photos/*.jpg)
  // -------------------------
  async function exportZip(){
    const captures = loadCaptures();
    if (!captures.length) return;

    if (typeof JSZip === "undefined"){
      setStatus("ZIP: JSZip fehlt");
      return;
    }

    setStatus("ZIP wird erstellt…");

    try{
      const zip = new JSZip();
      zip.file("captures.json", JSON.stringify(captures, null, 2));

      const photos = zip.folder("photos");
      const missing = [];

      for (const rec of captures){
        const id = rec.id;
        const entry = photoBlobs.get(id);
        if (!entry){
          missing.push(`#${id}`);
          continue;
        }
        photos.file(entry.filename, entry.blob); // Blob directly
      }

      if (missing.length){
        zip.file("missing_photos.txt",
          "Diese Records haben kein Foto im RAM.\n" +
          "Grund: Seite neu geladen oder Foto nicht in dieser Session aufgenommen.\n\n" +
          missing.join("\n")
        );
      }

      const blob = await zip.generateAsync({ type: "blob" });
      downloadBlob("capture_export.zip", blob);
      setStatus("ZIP exportiert");
    } catch(e){
      console.error(e);
      setStatus("ZIP Fehler");
    }
  }

  // -------------------------
  // Fullscreen toggle
  // -------------------------
  function isFullscreen(){
    return !!(document.fullscreenElement || document.webkitFullscreenElement);
  }
  function updateFullscreenBtn(){
    els.btnFullscreen.textContent = isFullscreen() ? "Normal" : "Fullscreen";
  }
  async function enterFullscreen(){
    const el = document.documentElement;
    if (el.requestFullscreen) return el.requestFullscreen();
    if (el.webkitRequestFullscreen) return el.webkitRequestFullscreen();
    throw new Error("Fullscreen not supported");
  }
  async function exitFullscreen(){
    if (document.exitFullscreen) return document.exitFullscreen();
    if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
    throw new Error("Exit fullscreen not supported");
  }

  els.btnFullscreen.addEventListener('click', async () => {
    try{
      if (!isFullscreen()) await enterFullscreen();
      else await exitFullscreen();
    } catch(e){
      setStatus("Fullscreen nicht verfügbar");
    } finally {
      updateFullscreenBtn();
    }
  });
  document.addEventListener('fullscreenchange', updateFullscreenBtn);
  document.addEventListener('webkitfullscreenchange', updateFullscreenBtn);

  // -------------------------
  // UI wiring
  // -------------------------
  els.btnStart.addEventListener('click', async () => {
    // Single user gesture: start camera + ask motion permission
    try{
      setStatus("Starte…");
      // Start motion permission first (still within user gesture)
      await requestMotionPermissionAndStart();

      // Then camera
      await startCamera({ facingMode: facing });
    } catch(e){
      console.error(e);
      setStatus("Start fehlgeschlagen");
      stopCamera();
    }
  });

  els.btnStop.addEventListener('click', stopCamera);
  els.btnShot.addEventListener('click', capturePhoto);
  els.btnExportZip.addEventListener('click', exportZip);

  els.btnClear.addEventListener('click', () => {
    sessionStorage.removeItem(STORE_KEY);
    saveCaptures([]);
    photoBlobs.clear(); // clear RAM photos too
    setStatus("Session gelöscht");
  });

  els.btnFlip.addEventListener('click', flipCamera);

  els.cameraSelect.addEventListener('change', async () => {
    await selectCameraByDeviceId(els.cameraSelect.value);
  });

  els.zoomRow.addEventListener('click', async (e) => {
    const btn = e.target.closest('.chip');
    if (!btn) return;
    const z = parseFloat(btn.dataset.z);

    [...els.zoomRow.querySelectorAll('.chip')].forEach(b => b.classList.remove('active'));
    btn.classList.add('active');

    const ok = await trySetZoom(z);
    if (!ok){
      setStatus("Zoom nicht verfügbar");
    }
  });

  // Init
  updatePortraitUI();
  saveCaptures(loadCaptures());
  updateSensorUI();
  updateFullscreenBtn();
})();
</script>
</body>
</html>
