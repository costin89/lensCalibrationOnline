<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Vanilla Camera App</title>
  <style>
    :root{
      --bg:#0b0c10; --card:#12141c; --muted:#a9b0c3; --text:#eef1ff;
      --accent:#7c5cff; --danger:#ff4d6d;
      --radius:18px;
    }
    *{box-sizing:border-box;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    body{margin:0;background:linear-gradient(180deg,#07080c, #0b0c10);color:var(--text);}
    .wrap{max-width:590px;margin:0 auto;min-height:100dvh;display:flex;flex-direction:column;}
    header{padding:14px 14px 8px 14px;display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;}
    .pill{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);padding:8px 10px;border-radius:999px;color:var(--muted);font-size:12px}
    .btn{
      border:0;border-radius:999px;padding:10px 12px;font-weight:650;
      background:rgba(255,255,255,.08);color:var(--text);
      border:1px solid rgba(255,255,255,.14);
      cursor:pointer; user-select:none;
    }
    .btn.primary{background:var(--accent);border-color:transparent;}
    .btn.danger{background:rgba(255,77,109,.14);border-color:rgba(255,77,109,.35);color:#ffd6de;}
    .btn:disabled{opacity:.45;cursor:not-allowed;}
    .stage{padding:10px 14px;flex:1;display:flex;flex-direction:column;gap:12px;}
    .viewfinder{
      position:relative;flex:1;min-height:380px;background:var(--card);
      border:1px solid rgba(255,255,255,.10);
      border-radius:var(--radius);
      overflow:hidden;
      box-shadow:0 20px 60px rgba(0,0,0,.35);
    }
    video{width:100%;height:100%;object-fit:cover;display:block;transform:scaleX(-1);}
    .back video{transform:none;} /* back camera: no mirror */
    .overlay{
      position:absolute;inset:0;display:flex;align-items:flex-start;justify-content:space-between;
      padding:10px;pointer-events:none;gap:10px;
    }
    .hud{display:flex;flex-direction:column;gap:6px;min-width:160px}
    .hud.right{align-items:flex-end;min-width:auto}
    .hud .pill{backdrop-filter:blur(10px);background:rgba(0,0,0,.35);border-color:rgba(255,255,255,.14);color:#d6dbf0}
    .portraitBlock{
      position:absolute;inset:0;display:none;align-items:center;justify-content:center;text-align:center;
      padding:22px;background:rgba(0,0,0,.72);backdrop-filter:blur(10px);
    }
    .portraitBlock.show{display:flex;}
    .portraitBlock .card{
      background:rgba(18,20,28,.85);border:1px solid rgba(255,255,255,.14);
      border-radius:22px;padding:18px;max-width:340px;
    }
    .portraitBlock h2{margin:0 0 8px 0;font-size:18px;}
    .portraitBlock p{margin:0;color:var(--muted);font-size:13px;line-height:1.35}
    .controls{
      background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.10);
      border-radius:22px;padding:12px;display:flex;flex-direction:column;gap:10px;
    }
    .row{display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;}
    select{
      background:rgba(255,255,255,.06);color:var(--text);border:1px solid rgba(255,255,255,.14);
      border-radius:12px;padding:10px;min-width:240px;max-width:100%;
    }
    .zoomRow{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
    .chip{
      border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);
      color:var(--text);padding:8px 10px;border-radius:999px;cursor:pointer;font-weight:650;
    }
    .chip.active{background:rgba(124,92,255,.22);border-color:rgba(124,92,255,.65);}
    .thumb{
      width:72px;height:72px;border-radius:16px;overflow:hidden;border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
    }
    .thumb img{width:100%;height:100%;object-fit:cover;display:block;}
    .toggle{
      display:flex;align-items:center;gap:10px;color:var(--muted);font-size:12px;
      background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.10);
      padding:10px 12px;border-radius:16px;
      width:100%;
    }
    .toggle input{transform:scale(1.15);}
    footer{padding:10px 14px 16px 14px;color:var(--muted);font-size:12px;line-height:1.35}
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;}
  </style>

  <!-- ZIP Library (JSZip) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>

<body>
<div class="wrap">
  <header>
    <div class="pill" id="statusPill">Bereit</div>

    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
      <button class="btn" id="btnFullscreen">Fullscreen</button>
      <button class="btn" id="btnMotion">Gyro/Kompass aktivieren</button>
      <button class="btn danger" id="btnStop" disabled>Stop</button>
    </div>
  </header>

  <div class="stage">
    <div class="viewfinder back" id="viewfinder">
      <div class="overlay">
        <div class="hud">
          <div class="pill" id="pillOrientation">Portrait: ?</div>
          <div class="pill" id="pillHeading">Heading: —</div>
          <div class="pill" id="pillYaw">Yaw: —</div>
          <div class="pill" id="pillPitch">Pitch: —</div>
          <div class="pill" id="pillRoll">Roll: —</div>
        </div>
        <div class="hud right">
          <div class="pill" id="pillZoom">Zoom: —</div>
          <div class="pill" id="pillCount">Records: 0</div>
        </div>
      </div>

      <video id="video" playsinline muted></video>

      <div class="portraitBlock" id="portraitBlock">
        <div class="card">
          <h2>Bitte ins Hochformat drehen</h2>
          <p>Fotoaufnahme ist nur im Portrait-Modus aktiv.</p>
        </div>
      </div>
    </div>

    <div class="controls">
      <div class="row">
        <button class="btn primary" id="btnStart">Kamera starten</button>
        <button class="btn primary" id="btnShot" disabled>Foto aufnehmen</button>
        <div class="thumb" title="Letztes Foto">
          <img id="thumb" alt="" />
        </div>
      </div>

      <div class="row">
        <label style="display:flex;gap:8px;align-items:center;color:var(--muted);font-size:12px;">
          Kamera:
          <select id="cameraSelect" disabled></select>
        </label>
        <button class="btn" id="btnFlip" disabled>Front/Back</button>
      </div>

      <div class="row">
        <div class="zoomRow" id="zoomRow" aria-label="Zoom">
          <span style="color:var(--muted);font-size:12px;margin-right:6px;">Zoom:</span>
          <button class="chip" data-z="0.5">0,5x</button>
          <button class="chip active" data-z="1">1x</button>
          <button class="chip" data-z="2">2x</button>
          <button class="chip" data-z="5">5x</button>
        </div>
      </div>

      <label class="toggle" title="Speichert das Foto zusätzlich als Base64 in sessionStorage/JSON. Kann sehr groß werden.">
        <input type="checkbox" id="chkBase64" />
        <div>
          <div style="color:var(--text);font-weight:650">Foto als Base64 im JSON speichern</div>
          <div style="margin-top:2px">Achtung: macht <code>sessionStorage</code> / JSON schnell riesig.</div>
        </div>
      </label>

      <div class="row">
        <button class="btn" id="btnExportJson" disabled>JSON export</button>
        <button class="btn" id="btnExportZip" disabled>ZIP export</button>
        <button class="btn danger" id="btnClear" disabled>Session löschen</button>
      </div>

      <div class="pill" id="hint">
        Hinweis: Auf iOS funktionieren 0,5x/2x/5x im Web nur, wenn Safari Zoom-Capabilities oder separate Kameras bereitstellt.
      </div>
    </div>
  </div>

  <footer>
    Für iOS am besten über <b>HTTPS</b>. Motion/Kompass brauchen Button-Klick. ZIP: <code>captures.json</code> + Fotos als Dateien.
  </footer>
</div>

<script>
(() => {
  const els = {
    video: document.getElementById('video'),
    viewfinder: document.getElementById('viewfinder'),
    portraitBlock: document.getElementById('portraitBlock'),

    statusPill: document.getElementById('statusPill'),
    pillOrientation: document.getElementById('pillOrientation'),
    pillHeading: document.getElementById('pillHeading'),
    pillYaw: document.getElementById('pillYaw'),
    pillPitch: document.getElementById('pillPitch'),
    pillRoll: document.getElementById('pillRoll'),
    pillZoom: document.getElementById('pillZoom'),
    pillCount: document.getElementById('pillCount'),

    cameraSelect: document.getElementById('cameraSelect'),

    btnStart: document.getElementById('btnStart'),
    btnStop: document.getElementById('btnStop'),
    btnShot: document.getElementById('btnShot'),
    btnFlip: document.getElementById('btnFlip'),
    btnMotion: document.getElementById('btnMotion'),
    btnFullscreen: document.getElementById('btnFullscreen'),

    btnExportJson: document.getElementById('btnExportJson'),
    btnExportZip: document.getElementById('btnExportZip'),
    btnClear: document.getElementById('btnClear'),

    chkBase64: document.getElementById('chkBase64'),

    thumb: document.getElementById('thumb'),
    zoomRow: document.getElementById('zoomRow'),
    hint: document.getElementById('hint'),
  };

  // -------------------------
  // session storage
  // -------------------------
  const STORE_KEY = "captures_v1";

  function loadCaptures(){
    try { return JSON.parse(sessionStorage.getItem(STORE_KEY) || "[]"); }
    catch { return []; }
  }

  function saveCaptures(arr){
    sessionStorage.setItem(STORE_KEY, JSON.stringify(arr));
    els.btnExportJson.disabled = arr.length === 0;
    els.btnExportZip.disabled  = arr.length === 0;
    els.btnClear.disabled      = arr.length === 0;
    els.pillCount.textContent  = `Records: ${arr.length}`;
  }

  function nextId(arr){
    const max = arr.reduce((m, x) => Math.max(m, Number(x.id)||0), 0);
    return max + 1;
  }

  function padId(id){ return String(id).padStart(4, "0"); }

  // Download helpers
  function downloadBlob(filename, blob){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }

  function downloadJson(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
    downloadBlob(filename, blob);
  }

  // -------------------------
  // camera state
  // -------------------------
  let stream = null;
  let currentDeviceId = null;
  let facing = 'environment'; // 'user' | 'environment'
  let videoTrack = null;

  // Photo cache (in-memory) for ZIP exporting within the current page session.
  // If you reload the page, only photos stored as Base64 in sessionStorage are still available.
  const photoCache = new Map(); // id -> dataUrl

  // -------------------------
  // sensor values
  // -------------------------
  let latest = {
    heading: null,
    yaw: null,
    pitch: null,
    roll: null,
    ts: null
  };

  function setStatus(text){ els.statusPill.textContent = text; }

  function isPortrait(){
    return window.matchMedia && window.matchMedia("(orientation: portrait)").matches;
  }

  function updatePortraitUI(){
    const ok = isPortrait();
    els.pillOrientation.textContent = "Portrait: " + (ok ? "Ja" : "Nein");
    els.portraitBlock.classList.toggle('show', !ok);
    els.btnShot.disabled = !ok || !stream;
  }

  window.addEventListener('orientationchange', updatePortraitUI);
  window.addEventListener('resize', updatePortraitUI);

  async function startCamera({ deviceId=null, facingMode='environment' } = {}) {
    stopCamera();

    const constraints = {
      audio: false,
      video: {
        width:  { ideal: 1280 },
        height: { ideal: 720 },
        facingMode: deviceId ? undefined : { ideal: facingMode },
        deviceId:  deviceId ? { exact: deviceId } : undefined
      }
    };

    try{
      setStatus("Kamera-Permission…");
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      els.video.srcObject = stream;

      await new Promise(res => els.video.onloadedmetadata = res);
      await els.video.play();

      videoTrack = stream.getVideoTracks()[0];
      const settings = videoTrack.getSettings?.() || {};
      currentDeviceId = settings.deviceId || deviceId || null;

      // UI mirror only for front cam
      if (facingMode === 'user') els.viewfinder.classList.remove('back');
      else els.viewfinder.classList.add('back');

      setStatus("Kamera läuft");
      els.btnStop.disabled = false;
      els.btnFlip.disabled = false;

      await refreshDeviceList();
      updateZoomUIFromCapabilities();
      updatePortraitUI();

    } catch(err){
      console.error(err);
      setStatus("Fehler: " + (err.name || "getUserMedia"));
      els.hint.textContent =
        "Tipp: iOS braucht HTTPS. Wenn Permission geblockt ist: iOS Einstellungen → Safari → Kamera → erlauben.";
      stopCamera();
    }
  }

  function stopCamera(){
    if (stream){
      stream.getTracks().forEach(t => t.stop());
    }
    stream = null;
    videoTrack = null;
    currentDeviceId = null;
    els.video.srcObject = null;
    els.btnShot.disabled = true;
    els.cameraSelect.disabled = true;
    els.btnFlip.disabled = true;
    els.btnStop.disabled = true;
    setStatus("Gestoppt");
    updatePortraitUI();
  }

  async function refreshDeviceList(){
    if (!navigator.mediaDevices?.enumerateDevices) return;

    const devices = await navigator.mediaDevices.enumerateDevices();
    const cams = devices.filter(d => d.kind === 'videoinput');

    els.cameraSelect.innerHTML = "";
    cams.forEach((c, idx) => {
      const opt = document.createElement('option');
      opt.value = c.deviceId;
      opt.textContent = c.label ? c.label : `Kamera ${idx+1}`;
      if (currentDeviceId && c.deviceId === currentDeviceId) opt.selected = true;
      els.cameraSelect.appendChild(opt);
    });

    els.cameraSelect.disabled = cams.length === 0;
  }

  function updateZoomUIFromCapabilities(){
    if (!videoTrack?.getCapabilities){
      els.pillZoom.textContent = "Zoom: —";
      return;
    }
    const caps = videoTrack.getCapabilities();
    if (caps && 'zoom' in caps){
      els.pillZoom.textContent = `Zoom: supported (${caps.zoom.min}–${caps.zoom.max})`;
      els.hint.textContent =
        "Zoom-Capability erkannt: Buttons versuchen applyConstraints(zoom). Falls iOS es ignoriert, ist das normal.";
    } else {
      els.pillZoom.textContent = "Zoom: nicht exposed";
      els.hint.textContent =
        "Safari/iOS expose’t Zoom oft nicht. Dann funktionieren 0,5x/2x/5x nur, wenn Safari separate Kameras listet.";
    }
  }

  async function trySetZoom(z){
    if (!videoTrack?.getCapabilities || !videoTrack?.applyConstraints) return false;
    const caps = videoTrack.getCapabilities();
    if (!caps || !('zoom' in caps)) return false;

    const target = Math.min(caps.zoom.max, Math.max(caps.zoom.min, z));
    try{
      await videoTrack.applyConstraints({ advanced: [{ zoom: target }] });
      els.pillZoom.textContent = `Zoom: ${target.toFixed(2)} (applyConstraints)`;
      return true;
    } catch(e){
      console.warn("applyConstraints zoom failed", e);
      return false;
    }
  }

  async function selectCameraByDeviceId(deviceId){
    const opt = [...els.cameraSelect.options].find(o => o.value === deviceId);
    const label = (opt?.textContent || "").toLowerCase();

    // Best-effort guess
    facing = (label.includes("front") || label.includes("vorne")) ? "user" : "environment";
    await startCamera({ deviceId, facingMode: facing });
  }

  async function flipCamera(){
    facing = (facing === 'environment') ? 'user' : 'environment';
    await startCamera({ facingMode: facing });
  }

  function dataUrlToParts(dataUrl){
    // "data:image/jpeg;base64,AAAA..."
    const match = /^data:(.*?);base64,(.*)$/.exec(dataUrl);
    if (!match) return { mime: "application/octet-stream", base64: "" };
    return { mime: match[1], base64: match[2] };
  }

  function stripImagesFromRecords(records){
    // remove photoBase64 to keep a small metadata file
    return records.map(r => {
      const copy = { ...r };
      delete copy.photoBase64;
      delete copy.photoMime;
      delete copy.photoFile;
      return copy;
    });
  }

  function capturePhoto(){
    if (!stream || !isPortrait()) return;

    const captures = loadCaptures();
    const id = nextId(captures);
    const fileName = `photo_${padId(id)}.jpg`;

    const v = els.video;
    const canvas = document.createElement('canvas');

    const w = v.videoWidth;
    const h = v.videoHeight;
    canvas.width = w;
    canvas.height = h;

    const ctx = canvas.getContext('2d');
    ctx.drawImage(v, 0, 0, w, h);

    const dataUrl = canvas.toDataURL('image/jpeg', 0.92);
    els.thumb.src = dataUrl;

    // Download Foto sofort
    const a = document.createElement('a');
    a.href = dataUrl;
    a.download = fileName;
    a.click();

    // cache photo for zip export while page open
    photoCache.set(id, dataUrl);

    // Metadaten record
    const record = {
      id,
      ts: new Date().toISOString(),
      heading: latest.heading,
      yaw: latest.yaw,
      pitch: latest.pitch,
      roll: latest.roll
    };

    // Optional: Base64 in JSON/sessionStorage speichern (RIESIG)
    if (els.chkBase64.checked){
      const parts = dataUrlToParts(dataUrl);
      record.photoFile = fileName;
      record.photoMime = parts.mime;
      record.photoBase64 = parts.base64;
    }

    captures.push(record);

    try{
      saveCaptures(captures);
      setStatus(`Foto + Werte gespeichert: #${id}`);
    } catch(e){
      // sessionStorage quota exceeded etc.
      console.warn(e);
      setStatus("Speichern fehlgeschlagen (Storage voll?)");
      // keep at least in memory cache; do not crash
    }
  }

  async function requestMotionPermission(){
    // Must be called from user gesture (button click)
    let ok = false;

    try{
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        const res = await DeviceOrientationEvent.requestPermission();
        ok = (res === 'granted');
      } else {
        ok = true; // other browsers: no prompt needed
      }
    } catch(e){
      console.warn("DeviceOrientationEvent permission error", e);
    }

    try{
      if (typeof DeviceMotionEvent !== 'undefined' &&
          typeof DeviceMotionEvent.requestPermission === 'function') {
        const res2 = await DeviceMotionEvent.requestPermission();
        ok = ok && (res2 === 'granted');
      }
    } catch(e){
      console.warn("DeviceMotionEvent permission error", e);
    }

    if (!ok){
      setStatus("Motion/Kompass abgelehnt");
      return;
    }

    setStatus("Motion/Kompass aktiv");

    window.addEventListener('deviceorientation', (ev) => {
      // Heading: iOS Safari (non-standard) is often best if available
      const heading = (typeof ev.webkitCompassHeading === 'number')
        ? ev.webkitCompassHeading
        : (typeof ev.alpha === 'number' ? ev.alpha : null);

      // pragmatic Euler-ish mapping:
      // yaw ~ alpha, pitch ~ beta, roll ~ gamma
      const yaw   = (typeof ev.alpha === 'number') ? ev.alpha : null;   // 0..360
      const pitch = (typeof ev.beta  === 'number') ? ev.beta  : null;   // -180..180
      const roll  = (typeof ev.gamma === 'number') ? ev.gamma : null;   // -90..90

      latest.heading = heading;
      latest.yaw = yaw;
      latest.pitch = pitch;
      latest.roll = roll;
      latest.ts = Date.now();

      els.pillHeading.textContent = (heading == null) ? "Heading: —" : `Heading: ${heading.toFixed(0)}°`;
      els.pillYaw.textContent     = (yaw == null)     ? "Yaw: —"     : `Yaw: ${yaw.toFixed(0)}°`;
      els.pillPitch.textContent   = (pitch == null)   ? "Pitch: —"   : `Pitch: ${pitch.toFixed(0)}°`;
      els.pillRoll.textContent    = (roll == null)    ? "Roll: —"    : `Roll: ${roll.toFixed(0)}°`;
    }, { passive: true });
  }

  // -------------------------
  // Fullscreen toggle
  // -------------------------
  function isFullscreen(){
    return !!(document.fullscreenElement || document.webkitFullscreenElement);
  }

  function updateFullscreenBtn(){
    els.btnFullscreen.textContent = isFullscreen() ? "Normal" : "Fullscreen";
  }

  async function enterFullscreen(){
    const el = document.documentElement;
    if (el.requestFullscreen) return el.requestFullscreen();
    if (el.webkitRequestFullscreen) return el.webkitRequestFullscreen();
    throw new Error("Fullscreen API not supported");
  }

  async function exitFullscreen(){
    if (document.exitFullscreen) return document.exitFullscreen();
    if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
    throw new Error("Exit fullscreen not supported");
  }

  els.btnFullscreen.addEventListener('click', async () => {
    try{
      if (!isFullscreen()) await enterFullscreen();
      else await exitFullscreen();
    } catch(e){
      console.warn(e);
      setStatus("Fullscreen nicht verfügbar");
    } finally {
      updateFullscreenBtn();
    }
  });

  document.addEventListener('fullscreenchange', updateFullscreenBtn);
  document.addEventListener('webkitfullscreenchange', updateFullscreenBtn);

  // -------------------------
  // Zoom buttons: try zoom; fallback: heuristic device switch by label
  // -------------------------
  els.zoomRow.addEventListener('click', async (e) => {
    const btn = e.target.closest('.chip');
    if (!btn) return;

    const z = parseFloat(btn.dataset.z);

    [...els.zoomRow.querySelectorAll('.chip')].forEach(b => b.classList.remove('active'));
    btn.classList.add('active');

    const zoomOk = await trySetZoom(z);
    if (zoomOk) return;

    const opts = [...els.cameraSelect.options];
    const want = (z === 0.5) ? ['ultra', 'weit', 'wide', '0.5']
               : (z >= 2) ? ['tele', '2', '3', '5']
               : ['wide', '1', 'standard'];

    const match = opts.find(o => want.some(k => (o.textContent || "").toLowerCase().includes(k)));
    if (match){
      setStatus("Wechsle Kamera (heuristisch) …");
      await selectCameraByDeviceId(match.value);
    } else {
      setStatus("Zoom/Lens nicht verfügbar");
    }
  });

  // -------------------------
  // Exports
  // -------------------------
  els.btnExportJson.addEventListener('click', () => {
    const captures = loadCaptures();
    downloadJson("captures.json", captures);
  });

  els.btnExportZip.addEventListener('click', async () => {
    const captures = loadCaptures();
    if (captures.length === 0) return;

    if (typeof JSZip === "undefined"){
      setStatus("ZIP: JSZip nicht geladen");
      return;
    }

    setStatus("ZIP wird erstellt…");

    try{
      const zip = new JSZip();

      // Always include both versions:
      zip.file("captures.json", JSON.stringify(captures, null, 2));
      zip.file("captures_no_images.json", JSON.stringify(stripImagesFromRecords(captures), null, 2));

      const photosFolder = zip.folder("photos");
      const missing = [];

      for (const rec of captures){
        const id = rec.id;
        const fileName = rec.photoFile || `photo_${padId(id)}.jpg`;

        // Prefer in-memory cache dataUrl, fallback to stored Base64 in record
        let dataUrl = photoCache.get(id) || null;
        let mime = null;
        let base64 = null;

        if (dataUrl){
          const parts = dataUrlToParts(dataUrl);
          mime = parts.mime;
          base64 = parts.base64;
        } else if (rec.photoBase64 && rec.photoMime){
          mime = rec.photoMime;
          base64 = rec.photoBase64;
        }

        if (base64){
          // JSZip can take base64 directly
          photosFolder.file(fileName, base64, { base64: true });
        } else {
          missing.push(`#${id} (${fileName})`);
        }
      }

      if (missing.length){
        zip.file("missing_photos.txt",
          "Für diese Records war kein Foto verfügbar.\n" +
          "Tipp: Entweder nicht neu laden (photoCache bleibt nur im RAM),\n" +
          "oder Checkbox 'Foto als Base64 im JSON speichern' aktivieren.\n\n" +
          missing.join("\n")
        );
      }

      const blob = await zip.generateAsync({ type: "blob" });
      downloadBlob("capture_export.zip", blob);
      setStatus("ZIP exportiert");
    } catch(e){
      console.error(e);
      setStatus("ZIP Fehler");
    }
  });

  els.btnClear.addEventListener('click', () => {
    sessionStorage.removeItem(STORE_KEY);
    saveCaptures([]);
    setStatus("Session gelöscht");
  });

  // -------------------------
  // UI events
  // -------------------------
  els.btnStart.addEventListener('click', () => startCamera({ facingMode: facing }));
  els.btnStop.addEventListener('click', stopCamera);
  els.btnFlip.addEventListener('click', flipCamera);
  els.btnShot.addEventListener('click', capturePhoto);
  els.btnMotion.addEventListener('click', requestMotionPermission);

  els.cameraSelect.addEventListener('change', async () => {
    await selectCameraByDeviceId(els.cameraSelect.value);
  });

  // -------------------------
  // init
  // -------------------------
  updatePortraitUI();
  saveCaptures(loadCaptures());
  updateFullscreenBtn();
})();
</script>
</body>
</html>
